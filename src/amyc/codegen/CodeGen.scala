package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
        expr match {
            case Variable(v) => 
                val idx = locals(v)
                GetLocal(idx)
            case IntLiteral(i) => 
                Const(i)
            case ArrayLiteral(length, value) =>                                     //      <===
                val old_mem_bound = lh.getFreshLocal()
                GetGlobal(memoryBoundary) <:> SetLocal(old_mem_bound) <:>
                GetLocal(old_mem_bound) <:> adtField(value.length) <:> SetGlobal(memoryBoundary) <:>
                GetLocal(old_mem_bound) <:> Const(length) <:> Store <:>
                value.zipWithIndex.map {
                    case (va, idx) =>  GetLocal(old_mem_bound) <:> adtField(idx) <:> Const(va) <:> Store
                } <:> GetLocal(old_mem_bound)
            case BooleanLiteral(b) => 
                Const(if (b) 1 else 0)
            case StringLiteral(s) => 
                mkString(s)
            case UnitLiteral() => 
                Const(0)        
            case Plus(lhs,rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Add
            case Minus(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
            case Times(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
            case AmyDiv(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Div
            case Mod(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
            case LessThan(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
            case LessEquals(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
            case AmyAnd(lhs, rhs) => 
                cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
            case AmyOr(lhs, rhs) => 
                cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
            case Equals(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
            case Concat(lhs, rhs) => 
                cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
            case Not(e) => 
                cgExpr(e) <:> Eqz
            case Neg(e) => 
                cgExpr(e) <:> Const(-1) <:> Mul
            case AmyCall(qname, args) =>                                          //        <===
                val fct = table.getFunction(qname).getOrElse(table.getConstructor(qname).get)
                fct match {
                    case FunSig(argTypes, retType, owner) => 
                        val name = fullName(owner,qname)
                        args.zip(argTypes).map{
                            case ((arg, true), argTp) => 
                                argTp match {
                                    case RangeType(s,e) => 
                                        val argIdx = lh.getFreshLocal()
                                        cgExpr(arg) <:> SetLocal(argIdx) <:>
                                        rangeCheck(argIdx, s, e, GetLocal(argIdx))
                                    case _ => 
                                        cgExpr(arg)
                                }
                            case ((arg, false), _) => 
                                cgExpr(arg)
                        } <:> Call(name)
                    case ConstrSig(argTypes, parent, index) => 
                        val old_mem_bound = lh.getFreshLocal()
                        GetGlobal(memoryBoundary) <:> SetLocal(old_mem_bound) <:>
                        GetLocal(old_mem_bound) <:> adtField(args.length) <:> SetGlobal(memoryBoundary) <:>
                        GetLocal(old_mem_bound) <:> Const(index) <:> Store <:>
                        args.zip(argTypes).zipWithIndex.map {
                            case (((arg, true), argTp), idx) => 
                                argTp match {
                                    case RangeType(s,e) => 
                                        val argIdx = lh.getFreshLocal()
                                        cgExpr(arg) <:> SetLocal(argIdx) <:>
                                        rangeCheck(argIdx, s, e, GetLocal(old_mem_bound) <:> adtField(idx) <:> GetLocal(argIdx) <:> Store)
                                    case _ => 
                                        GetLocal(old_mem_bound) <:> adtField(idx) <:> cgExpr(arg) <:> Store
                                }
                            case (((arg, false), _), idx) =>  
                                GetLocal(old_mem_bound) <:> adtField(idx) <:> cgExpr(arg) <:> Store
                        } <:> GetLocal(old_mem_bound)
                }
            case ArrayAccess(var_, elem, rc) =>                                     //      <===
                if (rc) {
                    val elemIdx = lh.getFreshLocal()
                    val varIdx = lh.getFreshLocal()
                    cgExpr(elem) <:> SetLocal(elemIdx) <:> cgExpr(var_) <:> SetLocal(varIdx) <:>
                    Const(0) <:> GetLocal(elemIdx) <:> Le_s <:> If_i32 <:>
                        GetLocal(elemIdx) <:> GetLocal(varIdx) <:> Load <:> Lt_s <:> If_i32 <:>
                            GetLocal(varIdx) <:> GetLocal(elemIdx) <:> Const(1) <:> Add <:> Const(4) <:> Mul <:> Add <:> Load <:>
                        Else <:>
                            mkString("Range Error!") <:> Call("Std_printString") <:> Unreachable <:>
                        End <:>
                    Else <:>
                        mkString("Range Error!") <:> Call("Std_printString") <:> Unreachable <:>
                    End
                } else {
                    cgExpr(var_) <:> cgExpr(elem) <:> Const(1) <:> Add <:> Const(4) <:> Mul <:> Add <:> Load
                }
            case ArrayLength(var_) =>                                               //      <===
                cgExpr(var_) <:> Load
            case Sequence(e1, e2) => 
                cgExpr(e1) <:> Drop <:> cgExpr(e2)
            case Let(df, value, body, rc) =>                                        //      <===
                val idx = lh.getFreshLocal()
                if (rc) {
                    val tp = df.tt.tpe
                    tp match {
                        case RangeType(s,e) => 
                            cgExpr(value) <:> SetLocal(idx) <:>
                            rangeCheck(idx, s, e, cgExpr(body)(locals + (df.name -> idx), lh))
                        case _ => 
                            cgExpr(value) <:> SetLocal(idx) <:> cgExpr(body)(locals + (df.name -> idx), lh)
                    }
                } else {
                    cgExpr(value) <:> SetLocal(idx) <:> cgExpr(body)(locals + (df.name -> idx), lh)
                }
            case Ite(cond, thenn, elze) => 
                cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End
            case Match(scrut, cases) => 
                val idx = lh.getFreshLocal()
                cgExpr(scrut) <:> SetLocal(idx) <:> cgCase(cases)(idx, locals, lh)
            case Error(msg) => 
                mkString("An error has occurred:") <:> cgExpr(msg) <:> Call(concatImpl.name) <:> Call("Std_printString") <:> Unreachable
        }
    }

    def rangeCheck(idx: Int, start:  Int, end: Int, body: Code): Code = {
        Const(start) <:> GetLocal(idx) <:> Le_s <:> If_i32 <:>
            GetLocal(idx) <:> Const(end) <:> Le_s <:> If_i32 <:>
                body <:>
            Else <:>
                mkString("Range Error!") <:> Call("Std_printString") <:> Unreachable <:>
            End <:>
        Else <:>
            mkString("Range Error!") <:> Call("Std_printString") <:> Unreachable <:>
        End
    }

    def cgCase(cases: List[MatchCase])(implicit scrutIdx: Integer, locals: Map[Identifier, Int],  lh: LocalsHandler): Code = {
        cases match {
            case MatchCase(pat, expr) :: rest => 
                pat match {
                    case WildcardPattern() => 
                        cgExpr(expr)(locals, lh)
                    case IdPattern(name) => 
                        val idx = lh.getFreshLocal()
                        GetLocal(scrutIdx) <:> SetLocal(idx) <:> cgExpr(expr)(locals + (name -> idx), lh)
                    case LiteralPattern(lit) => 
                        GetLocal(scrutIdx) <:> cgExpr(lit)(locals, lh) <:> Eq <:> If_i32 <:> cgExpr(expr)(locals, lh) <:> Else <:> cgCase(rest) <:> End
                    case CaseClassPattern(constr, args) => 
                        val (code, moreLocals) = matchAndBind(scrutIdx, pat)(locals, lh)
                        code <:> If_i32 <:> cgExpr(expr)(locals ++ moreLocals, lh) <:> Else <:> cgCase(rest) <:> End
                }
            case Nil => 
                cgExpr(Error(StringLiteral("Match Error!")))(locals, lh)

        }
    }

    def matchAndBind(scrutIdx: Integer, pat: Pattern)(implicit locals: Map[Identifier, Int],  lh: LocalsHandler): (Code, Map[Identifier, Int]) = {
        pat match {
            case WildcardPattern() => 
                (Const(1), Map())
            case IdPattern(name) => 
                val idx = lh.getFreshLocal()
                (GetLocal(scrutIdx) <:> SetLocal(idx) <:> Const(1), Map(name -> idx))
            case LiteralPattern(lit) => 
                (GetLocal(scrutIdx) <:> cgExpr(lit)(locals, lh) <:> Eq, Map())
            case CaseClassPattern(constr, args) => 
                val ConstrSig(argTypes, parent, index) = table.getConstructor(constr).get
                val (code, moreLocals) = args.zipWithIndex.map {
                    case (pt, idx) => 
                        val new_idx = lh.getFreshLocal()
                        val (cd, ml) = matchAndBind(new_idx, pt)
                        (GetLocal(scrutIdx) <:> adtField(idx) <:> Load <:> SetLocal(new_idx) <:> cd <:> And,ml)
                }.foldLeft((i2c(Const(1)), Map[Identifier, Int]())) { 
                    case ((cod, moreLocs), (cdf, mlf)) => 
                        (cod <:> cdf, moreLocs ++ mlf)
                    }
                (GetLocal(scrutIdx) <:> Load <:> Const(index) <:> Eq <:> If_i32 <:> code <:> Else <:> Const(0) <:> End, moreLocals)
        }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
